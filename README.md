Завдання 1.
Work Stealing:
Цей підхід оптимізує використання ресурсів, оскільки задачі, які не можуть бути виконані одним потоком, передаються іншим потокам, які мають менше роботи. Це забезпечує ефективніше використання всіх доступних процесорних ядер.
Завдяки механізму ForkJoinPool, підхід Work Stealing може бути ефективним для великих масивів, де робота може бути динамічно розподілена між потоками.
Work Dealing:
У цьому підході ми створюємо фіксовану кількість задач (одна задача для кожного потоку), і кожен потік виконує певну частину роботи. Це підходить для ситуацій, коли задачі можна легко розділити на незалежні частини.
Однак у випадку, коли одна частина масиву займає більше часу для обчислень, потоки можуть не використовувати свої ресурси ефективно, оскільки їх робота вже розподілена на початку і не може бути коригована в процесі виконання.
Час виконання:
Можна побачити різницю в часі виконання між обома підходами. Для більших масивів Work Stealing може показати кращі результати, оскільки завдяки динамічному розподілу роботи, потоки можуть ефективно обмінюватися задачами, зменшуючи час на виконання.
Work Dealing може виявитися менш ефективним для великих наборів даних, оскільки потоки можуть залишатися незавантаженими, якщо одна з частин масиву обробляється значно довше за інші.
Завдання 2.
Для реалізації завдання з використанням підходу Work Stealing в Java, я використовую Fork/Join Framework, оскільки цей підхід є оптимальним для задач, що потребують рекурсивного поділу роботи на менші підзадачі, які можуть бути оброблені паралельно.
Пояснення вибору підходу:
Work Stealing дозволяє виконувати підзадачі асинхронно, зберігаючи баланс між навантаженням різних потоків. Основні переваги цього підходу:
Кожен потік має свою чергу задач, і якщо його черга пуста, він може «вкрасти» підзадачу з іншого потоку, який має велику кількість непогашених задач.
Це дозволяє краще використовувати доступні процесори, особливо в умовах нерівномірного розподілу роботи.
Переваги підходу Work Stealing:
Краще розподілення навантаження. Якщо деякі підзадачі займають більше часу для виконання, інші потоки можуть забрати їх для обробки.
Покращена ефективність. Використовує ресурси більш ефективно, оскільки непотрібно чекати завершення інших задач, а можна паралельно виконувати підзадачі на інших потоках.
Легше реалізується в Java через Fork/Join. Бібліотека Fork/Join в Java має вбудовану підтримку Work Stealing через ForkJoinPool. Це значно полегшує реалізацію.
